Accounts where id in ( select distinct(id) from ( select id, datediff(login_date, lag(login_date,4) over ( partition by id order by login_date asc )) as diff from (select id, login_date from Logins group by id, login_date) b ) a where a.diff = 4 ) order by id
( select distinct(id) from ( select id, datediff(login_date, lag(login_date,4) over ( partition by id order by login_date asc )) as diff from (select id, login_date from Logins group by id, login_date) b ) a where a.diff = 4 ) valid_users inner join Accounts on valid_users.id = Accounts.id order by id
distinct b.item_category as CATEGORY, sum(case when weekday(a.order_date)=0 then quantity else 0 end) as MONDAY, sum(case when weekday(a.order_date)=1 then quantity else 0 end) as TUESDAY, sum(case when weekday(a.order_date)=2 then quantity else 0 end) as WEDNESDAY, sum(case when weekday(a.order_date)=3 then quantity else 0 end) as THURSDAY, sum(case when weekday(a.order_date)=4 then quantity else 0 end) as FRIDAY, sum(case when weekday(a.order_date)=5 then quantity else 0 end) as SATURDAY, sum(case when weekday(a.order_date)=6 then quantity else 0 end) as SUNDAY from Orders a right join Items b on a.item_id=b.item_id group by 1 order by 1
VALUES ROW(1),ROW(2), ROW(3), ROW(4), ROW(5), ROW(6), ROW(7) ), day_cat as ( SELECT * FROM (SELECT DISTINCT item_category as category FROM Items) a, dayofweek d), day_sale as ( SELECT DAYOFWEEK(ORDER_DATE) as day, i.item_category as category, sum(quantity) as amount FROM Orders o JOIN Items i ON i.item_id = o.item_id GROUP BY day, i.item_category ), day_sale_complete as ( SELECT dc.day, dc.category, IFNULL(ds.amount,0) as amount FROM day_cat dc LEFT JOIN day_sale ds ON dc.day = ds.day AND dc.category = ds.category ) SELECT category, sum(IF(day = 2, amount,0)) as MONDAY, sum(IF(day = 3, amount,0)) as TUESDAY, sum(IF(day = 4, amount,0)) as WEDNESDAY, sum(IF(day = 5, amount,0)) as THURSDAY, sum(IF(day = 6, amount,0)) as FRIDAY, sum(IF(day = 7, amount,0)) as SATURDAY, sum(IF(day = 1, amount,0)) as SUNDAY FROM day_sale_complete GROUP BY category ORDER BY category
( SELECT SUM(o.quantity * p.price) as sq, month(o.order_date) as m, c.customer_id, c.name FROM Customers as c INNER JOIN Orders as o ON c.customer_id = o.customer_id INNER JOIN Product as p ON o.Product_id = p.Product_id WHERE month(o.order_date) IN (6,7) GROUP BY o.customer_id, month(o.order_date) )*/ WITH sumquantity AS( select Customers.name, Customers.customer_id,sum(Orders.quantity*Product.price) as fprice, month(Orders.order_date) as mnth from Customers inner join Orders on Customers.customer_id = Orders.customer_id inner join Product on Orders.Product_id = Product.Product_id group by Customers.customer_id,mnth ) select s.name,s.customer_id from sumquantity as s inner join sumquantity as t on s.customer_id = t.customer_id and s.mnth = 6 and t.mnth = 7 and s.fprice >= 100 and t.fprice >= 100
FROM Users WHERE (mail REGEXP '^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode.com$')
date_format(order_date,'%Y-%m') as month, count(distinct order_id) as 'order_count' , count(distinct customer_id) as 'customer_count' from Orders where invoice > 20 group by date_format(order_date,'%Y-%m')
from (select paid_by, sum(amount) as amt_paid from Transactions t group by paid_by ) a right join Users u on a.paid_by = u.user_id ), after_receive_credit as (select apc.user_id, (apc.credit_left+coalesce(b.amt_received, 0)) as credit_left from (select paid_to, sum(amount) as amt_received from Transactions t group by paid_to ) b right join after_pay_credit apc on b.paid_to = apc.user_id ) select u.user_id, u.user_name, ifnull(arc.credit_left, u.credit) as credit, case when credit_left < 0 then 'Yes' else 'No' end as credit_limit_breached from after_receive_credit as arc right join Users u on arc.user_id = u.user_id
(select contest_id, gold_medal as 'id' from Contests union select contest_id, silver_medal as 'id' from Contests union select contest_id, bronze_medal as 'id' from Contests order by 1, 2) select name, mail from Users where user_id in (select gold_medal as 'id' from Contests group by 1 having count(*) >= 3) or user_id in (select distinct a1.id from a a1, a a2, a a3 where a1.id = a2.id and a2.id = a3.id and a1.contest_id + 1 = a2.contest_id and a2.contest_id + 1 = a3.contest_id)
FROM Employee e JOIN Department d ON e.DepartmentId = d.Id WHERE (e.DepartmentId, Salary) IN (SELECT DepartmentId, MAX(Salary) FROM Employee GROUP BY DepartmentId)
if (name like 'M%' or employee_id%2=0, 0, salary) as bonus from Employees group by employee_id
(SELECT order_id, MAX(quantity) AS maxqnt FROM OrdersDetails GROUP BY order_id), a AS (SELECT order_id, AVG(quantity) AS avgqnt FROM OrdersDetails GROUP by order_id) SELECT m.order_id FROM m WHERE maxqnt > (SELECT MAX(avgqnt) FROM a)
FROM OrdersDetails GROUP by order_id HAVING MAX(quantity) > (SELECT MAX(avg_q) FROM (SELECT order_id, AVG(quantity) AS avg_q FROM OrdersDetails GROUP BY order_id) a)
if (left(name,1)!='M' and employee_id%2=1, salary, 0) as bonus from Employees group by employee_id
from ordersDetails group by order_id having max(quantity) > (select m from (select (sum(quantity) / count(distinct product_id)) as m from ordersDetails group by order_id) a order by m desc limit 1)
if (name not like 'M%' and employee_id%2=1, salary, 0) as bonus from Employees group by employee_id
from Employee e, Department d where e.DepartmentID=d.Id and 3>( select count(distinct Salary) from Employee where Salary > e.Salary and DepartmentId=e.DepartmentId )
inner join Department d1 on e1.DepartmentId = d1.ID where 3 > (select count(distinct e2.salary) from Employee e2 where e2.Salary > e1.Salary and e1.DepartmentId = e2.DepartmentId)
dense_rank() over(partition by Department.Name order by Employee.Salary desc) as rank_count from Employee join Department on Employee.DepartmentId = Department.Id) as mytable where mytable.rank_count<=3
(SELECT min(event_date) as install_dt, player_id FROM Activity GROUP BY player_id) ) select a.install_dt, count(distinct a.player_id) as installs, round(1.00 * count( distinct b.player_id) / count(distinct a.player_id), 2) as Day1_retention from cte1 a left join Activity b on a.player_id = b.player_id and b.event_date-1 = a.install_dt group by a.install_dt
FROM ( SELECT student_id, course_id, grade, RANK() OVER (PARTITION BY student_id ORDER BY grade DESC, course_id) AS ranks FROM Enrollments ) f WHERE ranks = 1 GROUP BY student_id
FROM (SELECT (COUNT(DISTINCT r.post_id) / COUNT(DISTINCT a.post_id)) * 100 AS removal_percent, a.action_date FROM Actions a LEFT JOIN Removals r ON a.post_id = r.post_id WHERE a.extra = 'spam' GROUP BY a.action_date ) x
select action_date, a.post_id as act_post_id, count(a.post_id) as Actions_cnt, r.post_id as rem_post_id, count(r.post_id) as Removals_cnt from Actions a left join Removals r on a.post_id = r.post_id where action = 'report' and extra = 'spam' group by 1,2) ,cte2 as( select sum(Removals_cnt/Actions_cnt)/count(*)*100 as daily_percent from cte group by action_date) select round(sum(daily_percent)/count(*),2) as average_daily_percent from cte2
from ( select a.action_date, count(distinct r.post_id)/count(distinct a.post_id)*100 as daily_percent from Actions a left join Removals r on a.post_id=r.post_id where extra='spam' group by a.action_date ) t1
select action_date, count(distinct r.post_id)/count(distinct a.post_id)*100 as removal from Actions a left join Removals r on a.post_id = r.post_id where action = 'report' and extra = 'spam' group by 1) select round(avg(removal),2) as average_daily_percent from cte
GROUP BY viewer_id, view_date HAVING count(DISTINCT article_id) > 1 ORDER BY viewer_id
CASE WHEN rk IS NULL THEN 10 ELSE tmp.new_price END AS price FROM ( SELECT DISTINCT product_id FROM Products) p LEFT JOIN ( SELECT product_id, new_price, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) rk FROM Products WHERE change_date <= '2019-08-16' ) tmp ON p.product_id = tmp.product_id AND rk = 1
select seller_id, item_id, row_number() over (partition by seller_id order by order_date) as rr from Orders ), cte as ( select u.user_id as seller_id, case when u.favorite_brand = i.item_brand and rr = 2 then 'yes' when u.favorite_brand != i.item_brand and rr = 2 then 'no' when max(rr) OVER(partition by seller_id) < 2 then 'no' when rr is null then 'no' else NULL end as 2nd_item_fav_brand from second s join Items i USING (item_id) right join Users u on s.seller_id = u.user_id ) select * from cte where 2nd_item_fav_brand is not null
select user_id as seller_id, if(item_brand=favorite_brand,'yes','no') as 2nd_item_fav_brand from Users u left join (select seller_id, item_id, rank() over(partition by seller_id order by order_date) as order_rank from Orders) o inner join Items i on o.item_id=i.item_id and order_rank=2 on u.user_id=o.seller_id order by user_id
SELECT DISTINCT(product_id), LAST_VALUE(new_price) OVER(PARTITION BY product_id order by change_date RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS FINAL_PRICE FROM Products WHERE change_date <= '2019-08-16' ) SELECT product_id, FINAL_PRICE AS price FROM LAST_VALUE_TABLE UNION ALL SELECT DISTINCT(product_id) , 10 AS price FROM Products WHERE product_id NOT IN (SELECT product_id FROM LAST_VALUE_TABLE)
with cte1 as ( select user_id, count(*) cnt from Movie_Rating group by user_id ), cte2 as ( select distinct u.namefrom Users u inner join cte1 c on c.user_id=u.user_id order by cnt desc, u.name asc limit 1 ), cte3 as ( select movie_id, avg(rating) as avg_rating from Movie_Rating where month(created_at) = 2 and year(created_at) = 2020 group by movie_id ), cte4 as ( select m.title from cte3 inner join Movies m on m.movie_id = cte3.movie_id order by avg_rating desc, m.title asc limit 1 ) select name as results from cte2 union all select * from cte4
From( SELECT user_id,count(*) as number From Movie_Rating Group by user_id)a LEFT JOIN Users ON a.user_id = Users.user_id ORDER BY number DESC, name ASC Limit 1) UNION ALL (SELECT title as results From( SELECT movie_id, avg(rating) as rate From Movie_Rating WHERE LEFT(created_at,7) ='2020-02' Group by movie_id)b LEFT JOIN Movies ON b.movie_id = Movies.movie_id ORDER BY rate DESC, title ASC LIMIT 1)
with cte1 as ( select user_id, count(*) cnt from Movie_Rating group by user_id order by count(*) desc), cte2 as ( select distinct u.namefrom Users u inner join cte1 c on c.user_id=u.user_id order by cnt desc, u.name asc limit 1 ), cte3 as ( select movie_id, avg(rating) as avg_rating from Movie_Rating where month(created_at) = 2 and year(created_at) = 2020 group by movie_id ), cte4 as ( select m.title from cte3 inner join Movies m on m.movie_id = cte3.movie_id order by avg_rating desc, m.title asc limit 1 ) select name as results from cte2 union all select * from cte4
from Users u join (select user_id, count(rating) as cnt from Movie_Rating group by user_id) m using (user_id) order by m.cnt desc, u.name limit 1), r2 as (select m.title as results from Movies m join (select movie_id, avg(rating) as rt from Movie_Rating where date_format(created_at, '%Y-%m')='2020-02' group by movie_id) r using (movie_id) order by r.rt desc, m.title limit 1) select * from r1 union all select * from r2
select customer_id from Orders where product_name = 'C' ) , bought_a AS ( select customer_id from Orders where product_name = 'A' ) , bought_b AS ( select customer_id from Orders where product_name = 'B' ) select distinct customer_id, customer_name FROM bought_a join bought_b using (customer_id) left join bought_c c using(customer_id) join Customers using (customer_id) where c.customer_id is null
FROM ( SELECT SUM(B.apple_count) AS ba, SUM(B.orange_count) AS bo, SUM(IFNULL(C.apple_count,0)) AS ca, SUM(IFNULL(C.orange_count,0)) AS co FROM Boxes B LEFT OUTER JOIN Chests C ON (B.chest_id = C.chest_id) ) AS t1
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN RETURN ( select Nth_value(m.Salary,N) over(order by m.Salary Desc) as highest from (select distinct Salary from Employee) m order by highest Desc Limit 1 ); END
( SELECT SALARY ,RANK () OVER (ORDER BY salary desc) myrank FROM Employee) AS t WHERE myrank = 2
sum(case when team_id=host_team and host_goals>guest_goals then 3 else 0 end)+ sum(case when team_id=guest_team and guest_goals>host_goals then 3 else 0 end)+ sum(case when team_id=host_team and host_goals=guest_goals then 1 else 0 end)+ sum(case when team_id=guest_team and guest_goals=host_goals then 1 else 0 end) as num_points from Teams left join Matches on team_id = host_team or team_id = guest_team group by team_id order by num_points desc, team_id asc
round(sum(case when rating < 3 then 1 else 0 end)/count(q.query_name)*100,2) as poor_query_percentage from Queries q group by q.query_name
from Submissions l left join Submissions r on l.sub_id = r.parent_id where l.parent_id is null group by l.sub_id order by post_id
from Submissions a left join Submissions b on a.sub_id = b.parent_id where a.parent_id is null group by a.sub_id
period_state, start_date , end_date FROM ( SELECT 'Succeeded' as period_state, min(success_date) as start_date ,max(success_date) as end_date FROM ( SELECT success_date , datediff(success_date, LAG(success_date, 1) over(order by success_date asc)) as date_diff , row_number() over(order by success_date asc) as rnk , date_sub(success_date, interval (row_number() over(order by success_date asc)) day) as date_sub FROM Succeeded WHERE Year(success_date) = 2019 ) a group by date_sub UNION SELECT 'Failed' as period_state, min(fail_date) as start_date ,max(fail_date) as end_date FROM ( SELECT fail_date , datediff(fail_date, LAG(fail_date, 1) over(order by fail_date asc)) as date_diff , row_number() over(order by fail_date asc) as rnk , date_sub(fail_date, interval (row_number() over(order by fail_date asc)) day) as date_sub FROM Failed WHERE Year(fail_date) = 2019 ) a group by date_sub ) A order by start_date asc, end_date asc
SELECT DISTINCT user2_id FROM Friendship WHERE user1_id = 1 ), user1 AS ( SELECT DISTINCT user1_id FROM Friendship WHERE user2_id = 1 ) SELECT DISTINCT page_id AS recommended_page FROM Likes WHERE user_id IN ( SELECT user2_id FROM user2 UNION SELECT user1_id FROM user1 ) AND page_id NOT IN ( SELECT page_id FROM Likes WHERE user_id = 1 )
select c.country_name, case when avg(Weather_state) <= 15 then "Cold" when avg(Weather_state) >= 25 then "Hot" else "Warm" end as Weather_typefrom Weather w left join Countries c using (country_id) where month(day) = 11 group by 1
WHERE ID NOT IN ( SELECT ID FROM ( SELECT ID, EMAIL, RANK() OVER(PARTITION BY EMAIL ORDER BY ID) RNK FROM Person ) T WHERE RNK = 1 )
from SchoolA a join SchoolB b on a.student_id != b.student_id and a.student_name != b.student_name join SchoolC as c on b.student_id != c.student_id and a.student_id !=c.student_id and b.student_name != c.student_name and a.student_name !=c.student_name
select s.Seller_namefrom Seller s left join Orders o on s.Seller_id = o.Seller_id and Year(o.sale_date) = '2020' where o.sale_date is null order by s.Seller_name
select 1 as month UNION ALL select month + 1 from m where month < 12 ), d_stat as ( Select m.month, count(driver_id) as active_Drivers from m left join Drivers d on (date_add(concat('2020-', m.month, '-01'), INTERVAL 1 MONTH) > d.join_date) group by month ), a_Rides2020 as ( select month(requested_at) as month, count(*) as accepted_Rides from AcceptedRides a join Rides USING(ride_id) where year(requested_at) = '2020' group by month ) select month, active_Drivers, coalesce(accepted_Rides, 0) as accepted_Rides from d_stat left join a_Rides2020 USING(month)
select 1 as month UNION ALL select month + 1 from m where month < 12 ), d_stat as ( Select m.month, count(driver_id) as active_Drivers from m left join Drivers d on (date_add(concat('2020-', m.month, '-01'), INTERVAL 1 MONTH) > d.join_date) group by month ), a_Rides2020 as ( select month(requested_at) as month, count(*) as accepted_Rides from AcceptedRides a join Rides USING(ride_id) where year(requested_at) = '2020' group by month ) select month, active_Drivers, count(ride_id) as accepted_Rides from d_stat d left join (AcceptedRides join Rides USING(ride_id)) ON (d.month = Month(requested_at) and Year(requested_at) = '2020') group by month
CASE WHEN from_id < to_id THEN from_id ELSE to_id END AS person1, CASE WHEN from_id < to_id THEN to_id ELSE from_id END AS person2, COUNT(*) call_count, SUM(duration) total_duration FROM Calls c GROUP BY 1, 2
FROM seat a, seat b WHERE IF(a.id % 2 != 0, a.id + 1 = b.id, a.id - 1 = b.id) UNION SELECT id, student FROM seat WHERE id IN (SELECT MAX(id) FROM seat) AND IF(id % 2 != 0, id, NULL)
select f1.follower, count(distinct f2.follower) as numfrom follow f1 left join follow f2 on f1.follower = f2.followee where (f2.follower is not null) and (f1.followee != f2.follower) group by f1.follower order by f1.follower
if((x + y) > z and (y + z) > x and (z + x) > y, 'Yes', 'No') as 'triangle' from triangle
t_1.id, (CASE WHEN t_1.p_id IS Null THEN 'Root' WHEN t_1.p_id IS NOT Null AND t_2.id IS Null THEN 'Leaf' WHEN t_1.p_id IS NOT Null AND t_2.id IS Not Null THEN 'Inner' END) AS Type FROM tree t_1 LEFT JOIN tree t_2 ON t_1.id = t_2.p_id
